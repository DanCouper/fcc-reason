// Generated by BUCKLESCRIPT VERSION 1.7.1, PLEASE EDIT WITH CARE
'use strict';

var List       = require("bs-platform/lib/js/list.js");
var Curry      = require("bs-platform/lib/js/curry.js");
var Caml_obj   = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function pushIfAbsent(xs, x) {
  if (List.mem(x, xs)) {
    return xs;
  } else {
    return /* :: */[
            x,
            xs
          ];
  }
}

function unique(xs) {
  return List.rev(List.fold_left(pushIfAbsent, /* [] */0, xs));
}

function difference(list1, list2) {
  return unique(List.filter(function (x) {
                    return 1 - List.mem(x, list2);
                  })(list1));
}

function symmetricDifference(list1, list2) {
  return Pervasives.$at(difference(list2, list1), difference(list1, list2));
}

function uniq($staropt$star, l) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var eq$1 = eq;
  var _acc = /* [] */0;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var acc = _acc;
    if (l$1) {
      var xs = l$1[1];
      var x = l$1[0];
      if (List.exists(Curry._1(eq$1, x), xs)) {
        _l = xs;
        continue ;
        
      } else {
        _l = xs;
        _acc = /* :: */[
          x,
          acc
        ];
        continue ;
        
      }
    } else {
      return List.rev(acc);
    }
  };
}

function $neg$at(a, b) {
  return uniq(/* None */0, List.filter(function (v) {
                    return 1 - List.mem(v, b);
                  })(a));
}

function $neg$at$neg(a, b) {
  return Pervasives.$at($neg$at(a, b), $neg$at(b, a));
}

exports.pushIfAbsent        = pushIfAbsent;
exports.unique              = unique;
exports.difference          = difference;
exports.symmetricDifference = symmetricDifference;
exports.uniq                = uniq;
exports.$neg$at             = $neg$at;
exports.$neg$at$neg         = $neg$at$neg;
/* No side effect */
