// Generated by BUCKLESCRIPT VERSION 1.7.1, PLEASE EDIT WITH CARE
'use strict';

import * as List       from "bs-platform/lib/es6/list.js";
import * as Curry      from "bs-platform/lib/es6/curry.js";
import * as Caml_obj   from "bs-platform/lib/es6/caml_obj.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";

function pushIfAbsent(xs, x) {
  if (List.mem(x, xs)) {
    return xs;
  } else {
    return /* :: */[
            x,
            xs
          ];
  }
}

function unique(xs) {
  return List.rev(List.fold_left(pushIfAbsent, /* [] */0, xs));
}

function difference(list1, list2) {
  return unique(List.filter(function (x) {
                    return 1 - List.mem(x, list2);
                  })(list1));
}

function symmetricDifference(list1, list2) {
  return Pervasives.$at(difference(list2, list1), difference(list1, list2));
}

function uniq($staropt$star, l) {
  var eq = $staropt$star ? $staropt$star[0] : Caml_obj.caml_equal;
  var eq$1 = eq;
  var _acc = /* [] */0;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var acc = _acc;
    if (l$1) {
      var xs = l$1[1];
      var x = l$1[0];
      if (List.exists(Curry._1(eq$1, x), xs)) {
        _l = xs;
        continue ;
        
      } else {
        _l = xs;
        _acc = /* :: */[
          x,
          acc
        ];
        continue ;
        
      }
    } else {
      return List.rev(acc);
    }
  };
}

function $neg$at(a, b) {
  return uniq(/* None */0, List.filter(function (v) {
                    return 1 - List.mem(v, b);
                  })(a));
}

function $neg$at$neg(a, b) {
  return Pervasives.$at($neg$at(a, b), $neg$at(b, a));
}

export {
  pushIfAbsent        ,
  unique              ,
  difference          ,
  symmetricDifference ,
  uniq                ,
  $neg$at             ,
  $neg$at$neg         ,
  
}
/* No side effect */
