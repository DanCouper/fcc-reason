// Generated by BUCKLESCRIPT VERSION 1.7.1, PLEASE EDIT WITH CARE
'use strict';

import * as Block                   from "bs-platform/lib/es6/block.js";
import * as Caml_builtin_exceptions from "bs-platform/lib/es6/caml_builtin_exceptions.js";

function mapDigitToString(param) {
  switch (param) {
    case 0 : 
        return "0";
    case 1 : 
        return "1";
    case 2 : 
        return "2";
    case 3 : 
        return "3";
    case 4 : 
        return "4";
    case 5 : 
        return "5";
    case 6 : 
        return "6";
    case 7 : 
        return "7";
    case 8 : 
        return "8";
    case 9 : 
        return "9";
    case 10 : 
        return ".";
    
  }
}

function mapInputTypeToString(inputType) {
  if (typeof inputType === "number") {
    switch (inputType) {
      case 0 : 
          return "(";
      case 1 : 
          return ")";
      default:
        throw [
              Caml_builtin_exceptions.match_failure,
              [
                "/Users/danielcouper/Projects/Prototypes/fcc-reason/src/react/calculator.re",
                101,
                2
              ]
            ];
    }
  } else if (inputType.tag === 3) {
    switch (inputType[0]) {
      case 0 : 
          return "^";
      case 1 : 
          return "\xc3\x97";
      case 2 : 
          return "\xc3\xb7";
      case 3 : 
          return "+";
      case 4 : 
          return "-";
      
    }
  } else {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/danielcouper/Projects/Prototypes/fcc-reason/src/react/calculator.re",
            101,
            2
          ]
        ];
  }
}

function handleDigitInput(param) {
  var tokenisedInputs = param[1];
  var digit = param[0];
  var exit = 0;
  var exit$1 = 0;
  if (digit >= 10) {
    if (tokenisedInputs) {
      var match = tokenisedInputs[0];
      var match$1 = match[0];
      if (typeof match$1 === "number") {
        exit = 1;
      } else if (match$1.tag === 1) {
        if (match$1[0] !== 0) {
          return /* :: */[
                  /* tuple */[
                    /* Number */Block.__(1, [/* Float */0]),
                    match[1] + "."
                  ],
                  tokenisedInputs[1]
                ];
        } else {
          var match$2 = tokenisedInputs[1];
          if (match$2) {
            if (match$2[1]) {
              exit$1 = 2;
            } else {
              return tokenisedInputs;
            }
          } else {
            exit$1 = 2;
          }
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  } else {
    exit$1 = 2;
  }
  if (exit$1 === 2) {
    if (tokenisedInputs) {
      var match$3 = tokenisedInputs[0];
      var match$4 = match$3[0];
      if (typeof match$4 === "number") {
        exit = 1;
      } else if (match$4.tag === 1) {
        return /* :: */[
                /* tuple */[
                  /* Number */Block.__(1, [match$4[0]]),
                  match$3[1] + mapDigitToString(digit)
                ],
                tokenisedInputs[1]
              ];
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    if (digit >= 10) {
      return /* :: */[
              /* tuple */[
                /* Number */Block.__(1, [/* Float */0]),
                "0."
              ],
              tokenisedInputs
            ];
    } else {
      return /* :: */[
              /* tuple */[
                /* Number */Block.__(1, [/* Integer */1]),
                mapDigitToString(digit)
              ],
              tokenisedInputs
            ];
    }
  }
  
}

function updateInput(param) {
  var tokenisedInputs = param[1];
  var input = param[0];
  if (typeof input === "number") {
    return /* :: */[
            /* tuple */[
              input,
              mapInputTypeToString(input)
            ],
            tokenisedInputs
          ];
  } else if (input.tag) {
    return /* :: */[
            /* tuple */[
              input,
              mapInputTypeToString(input)
            ],
            tokenisedInputs
          ];
  } else {
    return handleDigitInput(/* tuple */[
                input[0],
                tokenisedInputs
              ]);
  }
}

function updateDisplayFromInput(tokenisedInputs) {
  var _inputs = tokenisedInputs;
  var _display = "";
  while(true) {
    var display = _display;
    var inputs = _inputs;
    if (inputs) {
      var rest = inputs[1];
      var str = inputs[0][1];
      if (rest) {
        _display = str + (" " + display);
        _inputs = rest;
        continue ;
        
      } else {
        return str + (" " + display);
      }
    } else {
      return display;
    }
  };
}

export {
  mapDigitToString       ,
  mapInputTypeToString   ,
  handleDigitInput       ,
  updateInput            ,
  updateDisplayFromInput ,
  
}
/* No side effect */
